<head>
  <meta charset="utf-8"/>
  <style>
    body {
      margin: 0;
      position: relative;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
    }
    div#backdrop {
      width: 100vw;
      height: 100vh;
      background-color: #172244;
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
  <script src='perlin.js'></script>
</head>
<body>
  <div id='backdrop'></div>
  <script>
    // SNOWFLAKES
    (function(global){
      if (!Array.isArray(global.animations)) {
        global.animations = [];
      }
      let animations = global.animations;
      let state;
      let canvas;
      animations.push({
        name: 'snow',
        canvas: () => canvas,
        init: (_canvas) => {
          canvas = _canvas;

          state = Array.from({ length: 1024 }, () => ({
            dx: 0,
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
          }));

          canvas.snowflake = document.createElement('canvas');
          canvas.snowflake.width = 8;
          canvas.snowflake.height = 8;
          
          const snowflake_context = canvas.snowflake.getContext('2d');
          snowflake_context.fillStyle = '#DDEEFF';
          snowflake_context.shadowColor = '#DDEEFF';
          snowflake_context.shadowBlur = 4;
          snowflake_context.beginPath();
          snowflake_context.ellipse(4, 4, 2, 2, 0, 0, Math.PI * 2);
          snowflake_context.closePath();
          snowflake_context.fill();
        },
        on_resize: (window) => {
          state = state.map(s => ({
            dx: s.dx,
            x: s.x / canvas.width * window.innerWidth,
            y: s.y / canvas.height * window.innerHeight,
          }));
        },
        integrate: (elapsed) => {
          state = state.map(s => {
            let dx = s.dx + (perlin.noise(s.x / 1024, s.y / 1024, elapsed / 4096) - 0.5) / 64;
            dx *= (s.dx * s.dx / 4096);
            let x = s.x + dx;
            if (x > canvas.width) x -= canvas.width + 8;
            if (x < -8) x += canvas.width + 8;
            let y = s.y + 1//+ 2 * perlin.noise(elapsed / 4096, s.x / 16);
            if (y > canvas.height) y -= canvas.height + 8;
            return { dx, x, y }
          });
        },
        render: () => {
          const context = canvas.getContext('2d');
          context.clearRect(0, 0, canvas.width, canvas.height);
          state.forEach((s, i) => {
            context.drawImage(canvas.snowflake, s.x + (perlin.noise(s.x / 256, s.y / 256) - 0.5) * 64, s.y)
          });
        },
      });
    })(this);
  </script>
  <script>
    // TREE LIGHTS
    (function(global){
      if (!Array.isArray(global.animations)) {
        global.animations = [];
      }
      let animations = global.animations;
      // let state;
      const create_paths = (x, y, size) => {
        const trunk = new Path2D(`M ${x - 4*size} ${y} q ${size} ${-4*size} ${size} ${-10*size} l ${6*size} 0 q 0 ${4*size} ${size} ${10*size}`);
        const tree = new Path2D(`M ${x - 12*size} ${y - 9*size} q ${3*size} ${-1*size} ${6*size} ${-5*size} l ${-4*size} 0 q ${3*size} ${-1*size} ${6*size} ${-7*size} l ${-4*size} 0 q ${3*size} ${-1*size} ${6*size} ${-9*size} l ${-4*size} 0 q ${3*size} ${-1*size} ${6*size} ${-11*size} q ${3*size} ${10*size} ${6*size} ${11*size} l ${-4*size} 0 q ${3*size} ${8*size} ${6*size} ${9*size} l ${-4*size} 0 q ${3*size} ${6*size} ${6*size} ${7*size} l ${-4*size} 0 q ${3*size} ${4*size} ${6*size} ${5*size}`);
        return { trunk, tree };
      }
      let canvas;
      let rendered = false;
      animations.push({
        name: 'tree_lights',
        canvas: () => canvas,
        init: (_canvas) => {
          canvas = _canvas;
        },
        on_resize: (window) => {
          rendered = false;
        },
        integrate: (elapsed) => {},
        render: () => {
          if (!rendered) {
            const context = canvas.getContext('2d');
            const paths = create_paths(canvas.width / 2, canvas.height, 20);
            context.fillStyle = '#663322';
            context.fill(paths.trunk);
            context.fillStyle = '#337744';
            context.fill(paths.tree);
            rendered = true;
          }
        },
      });
    })(this);
  </script>
  <script>
    const dt = 17;

    let previous = performance.now();
    let accumulator = 0; // frame-by-frame spare time accumulator
    let elapsed = 0; // total elapsed time in animation
    // this runs every frame
    function animate(timestamp) {
      // track the frame length
      const frame_time = timestamp - previous;
      previous = timestamp;
      // add it to the accumulator
      accumulator += frame_time;
      // run down the accumulator in dt sized chunks
      while (accumulator >= dt) {
        // run updates on each animation
        animations.forEach(a => a.integrate(elapsed));
        accumulator -= dt;
        elapsed += dt;
      }
      // render each animation
      animations.forEach(a => a.render());
      window.requestAnimationFrame(animate);
    }

    animations.forEach(a => {
      // give each animation a canvas
      let canvas = document.createElement('canvas');
      canvas.id = a.name;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      document.querySelector('body').appendChild(canvas);
      a.init(canvas);
    });
    // resize listener
    window.addEventListener('resize', () => {
      animations.forEach(a => {
        // run the animation's state update for this
        a.on_resize(window);
        // resize its canvas
        a.canvas().width = window.innerWidth;
        a.canvas().height = window.innerHeight;
      });
    });
    window.requestAnimationFrame(animate);
  </script>
</body>